{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Nebulo Documentation : https://olirice.github.io/nebulo Source Code : https://github.com/olirice/nebulo Instant GraphQL API for PostgreSQL Reflect a highly performant GraphQL API from an existing PostgreSQL database. Nebulo is a python library for building GraphQL APIs on top of PostgreSQL. It has a command line interface for reflecting databases wtih 0 code or can be added to existing SQLAlchemy projects (pending documentation). Note: Alpha Software The public API is expected to evolve over the next year. Production usage is not reccomended at this stage. TL;DR First, install nebulo $ pip install nebulo Then point the CLI at an existing PostgreSQL database using connection string format postgresql://<user>:<password>@<host>:<port>/<database_name> neb run -c postgresql://nebulo_user:password@localhost:4443/nebulo_db Visit your shiny new GraphQL API at http://localhost:5034/graphiql Next, check out the quickstart guide for a small end-to-end example. \u2014\u2014 \u2014\u2014","title":"Introduction"},{"location":"#nebulo","text":"Documentation : https://olirice.github.io/nebulo Source Code : https://github.com/olirice/nebulo Instant GraphQL API for PostgreSQL Reflect a highly performant GraphQL API from an existing PostgreSQL database. Nebulo is a python library for building GraphQL APIs on top of PostgreSQL. It has a command line interface for reflecting databases wtih 0 code or can be added to existing SQLAlchemy projects (pending documentation). Note: Alpha Software The public API is expected to evolve over the next year. Production usage is not reccomended at this stage.","title":"Nebulo"},{"location":"#tldr","text":"First, install nebulo $ pip install nebulo Then point the CLI at an existing PostgreSQL database using connection string format postgresql://<user>:<password>@<host>:<port>/<database_name> neb run -c postgresql://nebulo_user:password@localhost:4443/nebulo_db Visit your shiny new GraphQL API at http://localhost:5034/graphiql Next, check out the quickstart guide for a small end-to-end example. \u2014\u2014 \u2014\u2014","title":"TL;DR"},{"location":"authentication/","text":"Authentication The approach to authentication and row level security were shamelessly borrowed from the postgraphile project, a similar (but much more mature) PostgreSQL to GraphQL project written in Javascript. Please see their security documentation for instructions on setting up secure auth for api users. Note that JWT identifier and JWT secret can be passed to the nebulo CLI via --jwt-identifier \"public.my_jwt\" and --jwt-secret \"my_jwt_secret\" to cause functions returning the JWT type to reflect correctly. If the JWT type contains a role field, that role will be used to execute SQL statements for authenticated user's requests. Anonymous users' requests execute with the connections default role unless a default role is passed using the --default-role option","title":"Authentication"},{"location":"authentication/#authentication","text":"The approach to authentication and row level security were shamelessly borrowed from the postgraphile project, a similar (but much more mature) PostgreSQL to GraphQL project written in Javascript. Please see their security documentation for instructions on setting up secure auth for api users. Note that JWT identifier and JWT secret can be passed to the nebulo CLI via --jwt-identifier \"public.my_jwt\" and --jwt-secret \"my_jwt_secret\" to cause functions returning the JWT type to reflect correctly. If the JWT type contains a role field, that role will be used to execute SQL statements for authenticated user's requests. Anonymous users' requests execute with the connections default role unless a default role is passed using the --default-role option","title":"Authentication"},{"location":"performance/","text":"Performance Performance Enabling Features: All queries are handled in a single round-trip to the database. No N+1 problems here! SQL queries only fetch requested fields SQL queries return JSON which significantly reduces database IO when joins are present Fully async / built on starlette Benchmarks Performance depends on netowrk, number of workers, log level etc. Despite all that, here are rough figures with postgres and the webserver running on a mid-tier 2017 Macbook Pro. Benchmarking 0.0.0.0 (be patient) Server Software: uvicorn Server Hostname: 0.0.0.0 Server Port: 5034 Document Path: / Document Length: 310 bytes Concurrency Level: 10 Time taken for tests: 5.571 seconds Complete requests: 1000 Failed requests: 0 Total transferred: 436000 bytes Total body sent: 245000 HTML transferred: 310000 bytes Requests per second: 179.49 [#/sec] (mean) Time per request: 55.712 [ms] (mean) Time per request: 5.571 [ms] (mean, across all concurrent requests) Transfer rate: 76.43 [Kbytes/sec] received 42.95 kb/s sent 119.37 kb/s total Connection Times (ms) min mean[+/-sd] median max Connect: 0 0 0.0 0 0 Processing: 17 55 18.7 52 98 Waiting: 17 55 18.7 51 98 Total: 18 55 18.7 52 98 Percentage of the requests served within a certain time (ms) 50% 52 66% 60 75% 65 80% 69 90% 80 95% 90 98% 94 99% 95 100% 98 (longest request) So approximately 180 requests/second responding in sub 100 milliseconds. Note that under normal load, response times are significantly faster. Percentage of the requests served within a certain time (ms) 50% 17 66% 19 75% 19 80% 20 90% 21 95% 24 98% 26 99% 30 100% 38 (longest request)","title":"Performance"},{"location":"performance/#performance","text":"Performance Enabling Features: All queries are handled in a single round-trip to the database. No N+1 problems here! SQL queries only fetch requested fields SQL queries return JSON which significantly reduces database IO when joins are present Fully async / built on starlette Benchmarks Performance depends on netowrk, number of workers, log level etc. Despite all that, here are rough figures with postgres and the webserver running on a mid-tier 2017 Macbook Pro. Benchmarking 0.0.0.0 (be patient) Server Software: uvicorn Server Hostname: 0.0.0.0 Server Port: 5034 Document Path: / Document Length: 310 bytes Concurrency Level: 10 Time taken for tests: 5.571 seconds Complete requests: 1000 Failed requests: 0 Total transferred: 436000 bytes Total body sent: 245000 HTML transferred: 310000 bytes Requests per second: 179.49 [#/sec] (mean) Time per request: 55.712 [ms] (mean) Time per request: 5.571 [ms] (mean, across all concurrent requests) Transfer rate: 76.43 [Kbytes/sec] received 42.95 kb/s sent 119.37 kb/s total Connection Times (ms) min mean[+/-sd] median max Connect: 0 0 0.0 0 0 Processing: 17 55 18.7 52 98 Waiting: 17 55 18.7 51 98 Total: 18 55 18.7 52 98 Percentage of the requests served within a certain time (ms) 50% 52 66% 60 75% 65 80% 69 90% 80 95% 90 98% 94 99% 95 100% 98 (longest request) So approximately 180 requests/second responding in sub 100 milliseconds. Note that under normal load, response times are significantly faster. Percentage of the requests served within a certain time (ms) 50% 17 66% 19 75% 19 80% 20 90% 21 95% 24 98% 26 99% 30 100% 38 (longest request)","title":"Performance"},{"location":"quickstart/","text":"Quickstart For this example we're going to create a simple blogging platform. We'll start by creating a minimal database schema. Then we'll use nebulo to reflect our GraphQL API. Finally, we'll query from that API. Installation Requires: Python 3.7+ pip install nebulo Database Setup If you don't have PostgreSQL installed locally, the following docker command creates an instance with the connection string used for the remainder of the quickstart guide. docker run --rm --name nebulo_demo -p 4443 :5432 -d -e POSTGRES_DB = nebulo_db -e POSTGRES_PASSWORD = password -e POSTGRES_USER = nebulo_user -d postgres Next, we need to define our database schema. We need a table for accounts, and another for blog posts. All blog posts must be associated with an author in the accounts table. Additionally, we don't want to allow users to update or delete their blog post. -- blog_schema.sql CREATE TABLE public . account ( id SERIAL PRIMARY KEY , name TEXT NOT NULL , created_at TIMESTAMP NOT NULL DEFAULT now () ); CREATE TABLE public . blog_post ( id SERIAL PRIMARY KEY , title TEXT NOT NULL , body TEXT , author_id INT REFERENCES account ( id ), created_at TIMESTAMP NOT NULL DEFAULT now () ); INSERT INTO account ( id , name ) VALUES ( 1 , 'Oliver' ), ( 2 , 'Buddy' ); INSERT INTO blog_post ( id , author_id , title ) VALUES ( 1 , 1 , 'First Post' ), ( 2 , 1 , 'Sanitize all the things!' ), ( 3 , 2 , 'To Bite or not to Bite' ); COMMENT ON TABLE blog_post IS E '@exclude update, delete' ; Note the comment to exclude updates and deletes from blog posts. The same comment format can also be applied to exclude columns from reflection e.g. password hashes. GraphQL Schema Now we're ready to reflect the database schema into a GraphQL schema. The GraphQL schema document describes our API's types, fields, and relationships between entities. If you're new to GraphQL check out their documentation for more information. To inspect the GraphQL schema neb dump-schema -c postgresql://nebulo_user:password@localhost:4443/nebulo_db where the connection string provided by -c is in the format postgresql://<user>:<password>@<host>:<port>/<database_name> Which outputs the schema below type Query { \"\"\"Reads a single Account using its globally unique ID\"\"\" account ( nodeId: ID !): Account \"\"\"Reads and enables pagination through a set of Account\"\"\" allAccounts ( first: Int , last: Int , before: Cursor , after: Cursor , condition: accountCondition ): AccountConnection \"\"\"Reads a single BlogPost using its globally unique ID\"\"\" blogPost ( nodeId: ID !): BlogPost \"\"\"Reads and enables pagination through a set of BlogPost\"\"\" allBlogPosts ( first: Int , last: Int , before: Cursor , after: Cursor , condition: blogPostCondition ): BlogPostConnection } type Mutation { \"\"\"Creates a single Account.\"\"\" createAccount ( input: CreateAccountInput !): CreateAccountPayload \"\"\"Updates a single Account using its globally unique id and a patch.\"\"\" updateAccount ( input: UpdateAccountInput !): UpdateAccountPayload \"\"\"Delete a single Account using its globally unique id and a patch.\"\"\" deleteAccount ( input: DeleteAccountInput !): DeleteAccountPayload \"\"\"Creates a single BlogPost.\"\"\" createBlogPost ( input: CreateBlogPostInput !): CreateBlogPostPayload } type Account implements NodeInterface { nodeId: ID ! id: Int ! name: String ! createdAt: DateTime ! \"\"\"Reads and enables pagination through a set of BlogPost\"\"\" blogPostsByIdToAuthorId ( first: Int , last: Int , before: Cursor , after: Cursor , condition: blogPostCondition ): BlogPostConnection ! } \"\"\"An object with a nodeId\"\"\" interface NodeInterface { \"\"\"The global id of the object.\"\"\" nodeId: ID ! } scalar DateTime type BlogPostConnection { edges: [ BlogPostEdge !]! pageInfo: PageInfo ! totalCount: Int ! } type BlogPostEdge { cursor: Cursor node: BlogPost } scalar Cursor < abridged output > Notice that our API detected the foreign key relationship between Account and BlogPost and created blogPostsByIdToAuthorId and accountByAuthorIdToId on their base types respectively. Query the API To start the API server, execute neb run passing in a connection to the database. neb run -c postgresql://nebulo_user:password@localhost:4443/nebulo_db In addition to handling GraphQL requests, nebulo also serves the GraphiQL explorer locally at http://localhost:5034/graphiql . Enter your query in GraphiQL and click the arrow icon to execute it. You're all done!","title":"Quickstart"},{"location":"quickstart/#quickstart","text":"For this example we're going to create a simple blogging platform. We'll start by creating a minimal database schema. Then we'll use nebulo to reflect our GraphQL API. Finally, we'll query from that API.","title":"Quickstart"},{"location":"quickstart/#installation","text":"Requires: Python 3.7+ pip install nebulo","title":"Installation"},{"location":"quickstart/#database-setup","text":"If you don't have PostgreSQL installed locally, the following docker command creates an instance with the connection string used for the remainder of the quickstart guide. docker run --rm --name nebulo_demo -p 4443 :5432 -d -e POSTGRES_DB = nebulo_db -e POSTGRES_PASSWORD = password -e POSTGRES_USER = nebulo_user -d postgres Next, we need to define our database schema. We need a table for accounts, and another for blog posts. All blog posts must be associated with an author in the accounts table. Additionally, we don't want to allow users to update or delete their blog post. -- blog_schema.sql CREATE TABLE public . account ( id SERIAL PRIMARY KEY , name TEXT NOT NULL , created_at TIMESTAMP NOT NULL DEFAULT now () ); CREATE TABLE public . blog_post ( id SERIAL PRIMARY KEY , title TEXT NOT NULL , body TEXT , author_id INT REFERENCES account ( id ), created_at TIMESTAMP NOT NULL DEFAULT now () ); INSERT INTO account ( id , name ) VALUES ( 1 , 'Oliver' ), ( 2 , 'Buddy' ); INSERT INTO blog_post ( id , author_id , title ) VALUES ( 1 , 1 , 'First Post' ), ( 2 , 1 , 'Sanitize all the things!' ), ( 3 , 2 , 'To Bite or not to Bite' ); COMMENT ON TABLE blog_post IS E '@exclude update, delete' ; Note the comment to exclude updates and deletes from blog posts. The same comment format can also be applied to exclude columns from reflection e.g. password hashes.","title":"Database Setup"},{"location":"quickstart/#graphql-schema","text":"Now we're ready to reflect the database schema into a GraphQL schema. The GraphQL schema document describes our API's types, fields, and relationships between entities. If you're new to GraphQL check out their documentation for more information. To inspect the GraphQL schema neb dump-schema -c postgresql://nebulo_user:password@localhost:4443/nebulo_db where the connection string provided by -c is in the format postgresql://<user>:<password>@<host>:<port>/<database_name> Which outputs the schema below type Query { \"\"\"Reads a single Account using its globally unique ID\"\"\" account ( nodeId: ID !): Account \"\"\"Reads and enables pagination through a set of Account\"\"\" allAccounts ( first: Int , last: Int , before: Cursor , after: Cursor , condition: accountCondition ): AccountConnection \"\"\"Reads a single BlogPost using its globally unique ID\"\"\" blogPost ( nodeId: ID !): BlogPost \"\"\"Reads and enables pagination through a set of BlogPost\"\"\" allBlogPosts ( first: Int , last: Int , before: Cursor , after: Cursor , condition: blogPostCondition ): BlogPostConnection } type Mutation { \"\"\"Creates a single Account.\"\"\" createAccount ( input: CreateAccountInput !): CreateAccountPayload \"\"\"Updates a single Account using its globally unique id and a patch.\"\"\" updateAccount ( input: UpdateAccountInput !): UpdateAccountPayload \"\"\"Delete a single Account using its globally unique id and a patch.\"\"\" deleteAccount ( input: DeleteAccountInput !): DeleteAccountPayload \"\"\"Creates a single BlogPost.\"\"\" createBlogPost ( input: CreateBlogPostInput !): CreateBlogPostPayload } type Account implements NodeInterface { nodeId: ID ! id: Int ! name: String ! createdAt: DateTime ! \"\"\"Reads and enables pagination through a set of BlogPost\"\"\" blogPostsByIdToAuthorId ( first: Int , last: Int , before: Cursor , after: Cursor , condition: blogPostCondition ): BlogPostConnection ! } \"\"\"An object with a nodeId\"\"\" interface NodeInterface { \"\"\"The global id of the object.\"\"\" nodeId: ID ! } scalar DateTime type BlogPostConnection { edges: [ BlogPostEdge !]! pageInfo: PageInfo ! totalCount: Int ! } type BlogPostEdge { cursor: Cursor node: BlogPost } scalar Cursor < abridged output > Notice that our API detected the foreign key relationship between Account and BlogPost and created blogPostsByIdToAuthorId and accountByAuthorIdToId on their base types respectively.","title":"GraphQL Schema"},{"location":"quickstart/#query-the-api","text":"To start the API server, execute neb run passing in a connection to the database. neb run -c postgresql://nebulo_user:password@localhost:4443/nebulo_db In addition to handling GraphQL requests, nebulo also serves the GraphiQL explorer locally at http://localhost:5034/graphiql . Enter your query in GraphiQL and click the arrow icon to execute it. You're all done!","title":"Query the API"},{"location":"sqlalchemy_interop/","text":"SQLAlchemy Interop Example The following is a complete example showing how to add a nebulo-powered GraphQL API to an existing SQLAlchemy project. If you use docker, start the database with docker run --rm --name nebulo_example_local -p 5522 :5432 -d -e POSTGRES_DB = nebulo_example -e POSTGRES_PASSWORD = app_password POSTGRES_USER = app_user -d postgres or update DATABASE_URI in app.py to the connection string for your database server. # app.py import uvicorn from databases import Database from nebulo.gql.sqla_to_gql import sqla_models_to_graphql_schema from nebulo.server.exception import http_exception from nebulo.server.routes import GRAPHIQL_STATIC_FILES , get_graphql_route , graphiql_route from sqlalchemy import Column , DateTime , ForeignKey , Integer , Text , create_engine from sqlalchemy import text as sql_text from sqlalchemy.ext.declarative import declarative_base from sqlalchemy.orm import relationship from starlette.applications import Starlette from starlette.exceptions import HTTPException from starlette.routing import Mount , Route # Config DATABASE_URI = \"postgresql://app_user:app_password@localhost:5522/nebulo_example\" ##################### # SQLAlchemy Models # ##################### Base = declarative_base () class Author ( Base ): __tablename__ = \"author\" id = Column ( Integer , primary_key = True , comment = \"@exclude insert, update\" ) name = Column ( Text , nullable = False ) created_at = Column ( DateTime , nullable = False , server_default = sql_text ( \"now()\" ), comment = \"@exclude insert, update\" , ) books = relationship ( \"Book\" , uselist = True ) class Book ( Base ): __tablename__ = \"book\" id = Column ( Integer , primary_key = True , comment = \"@exclude insert, update\" ) title = Column ( Text , nullable = False ) author_id = Column ( Integer , ForeignKey ( \"author.id\" ), nullable = False ) created_at = Column ( DateTime , nullable = False , default = sql_text ( \"now()\" ), comment = \"@exclude insert, update\" , ) author = relationship ( \"Author\" ) ################################# # Starlette Application Factory # ################################# def create_app ( connection_str , sqla_models ) -> Starlette : \"\"\"Create the Starlette app\"\"\" # Convert sqla models to graphql schema gql_schema = sqla_models_to_graphql_schema ( sqla_models , sql_functions = [], ) # Build Starlette app database = Database ( connection_str ) graphql_route = get_graphql_route ( gql_schema , database , jwt_secret = None , default_role = None ) routes = [ Route ( \"/\" , graphql_route , methods = [ \"POST\" ]), Route ( \"/graphiql\" , graphiql_route , methods = [ \"GET\" ]), Mount ( \"/static\" , GRAPHIQL_STATIC_FILES , name = \"static\" ), ] _app = Starlette ( routes = routes , exception_handlers = { HTTPException : http_exception }, on_startup = [ database . connect ], on_shutdown = [ database . disconnect ], ) return _app # Instantiate the app APP = create_app ( connection_str = DATABASE_URI , sqla_models = [ Author , Book ]) if __name__ == \"__main__\" : # Create Tables with create_engine ( DATABASE_URI ) . connect () as sqla_engine : Base . metadata . create_all ( bind = sqla_engine ) uvicorn . run ( \"app:APP\" , host = \"0.0.0.0\" , port = 5082 , log_level = \"info\" , reload = False , ) Run the example with python app.py and navigate to http://0.0.0.0:5082/graphiql to interact with it","title":"SQLAlchemy Interop"},{"location":"sqlalchemy_interop/#sqlalchemy-interop-example","text":"The following is a complete example showing how to add a nebulo-powered GraphQL API to an existing SQLAlchemy project. If you use docker, start the database with docker run --rm --name nebulo_example_local -p 5522 :5432 -d -e POSTGRES_DB = nebulo_example -e POSTGRES_PASSWORD = app_password POSTGRES_USER = app_user -d postgres or update DATABASE_URI in app.py to the connection string for your database server. # app.py import uvicorn from databases import Database from nebulo.gql.sqla_to_gql import sqla_models_to_graphql_schema from nebulo.server.exception import http_exception from nebulo.server.routes import GRAPHIQL_STATIC_FILES , get_graphql_route , graphiql_route from sqlalchemy import Column , DateTime , ForeignKey , Integer , Text , create_engine from sqlalchemy import text as sql_text from sqlalchemy.ext.declarative import declarative_base from sqlalchemy.orm import relationship from starlette.applications import Starlette from starlette.exceptions import HTTPException from starlette.routing import Mount , Route # Config DATABASE_URI = \"postgresql://app_user:app_password@localhost:5522/nebulo_example\" ##################### # SQLAlchemy Models # ##################### Base = declarative_base () class Author ( Base ): __tablename__ = \"author\" id = Column ( Integer , primary_key = True , comment = \"@exclude insert, update\" ) name = Column ( Text , nullable = False ) created_at = Column ( DateTime , nullable = False , server_default = sql_text ( \"now()\" ), comment = \"@exclude insert, update\" , ) books = relationship ( \"Book\" , uselist = True ) class Book ( Base ): __tablename__ = \"book\" id = Column ( Integer , primary_key = True , comment = \"@exclude insert, update\" ) title = Column ( Text , nullable = False ) author_id = Column ( Integer , ForeignKey ( \"author.id\" ), nullable = False ) created_at = Column ( DateTime , nullable = False , default = sql_text ( \"now()\" ), comment = \"@exclude insert, update\" , ) author = relationship ( \"Author\" ) ################################# # Starlette Application Factory # ################################# def create_app ( connection_str , sqla_models ) -> Starlette : \"\"\"Create the Starlette app\"\"\" # Convert sqla models to graphql schema gql_schema = sqla_models_to_graphql_schema ( sqla_models , sql_functions = [], ) # Build Starlette app database = Database ( connection_str ) graphql_route = get_graphql_route ( gql_schema , database , jwt_secret = None , default_role = None ) routes = [ Route ( \"/\" , graphql_route , methods = [ \"POST\" ]), Route ( \"/graphiql\" , graphiql_route , methods = [ \"GET\" ]), Mount ( \"/static\" , GRAPHIQL_STATIC_FILES , name = \"static\" ), ] _app = Starlette ( routes = routes , exception_handlers = { HTTPException : http_exception }, on_startup = [ database . connect ], on_shutdown = [ database . disconnect ], ) return _app # Instantiate the app APP = create_app ( connection_str = DATABASE_URI , sqla_models = [ Author , Book ]) if __name__ == \"__main__\" : # Create Tables with create_engine ( DATABASE_URI ) . connect () as sqla_engine : Base . metadata . create_all ( bind = sqla_engine ) uvicorn . run ( \"app:APP\" , host = \"0.0.0.0\" , port = 5082 , log_level = \"info\" , reload = False , ) Run the example with python app.py and navigate to http://0.0.0.0:5082/graphiql to interact with it","title":"SQLAlchemy Interop Example"},{"location":"supported_entities/","text":"Supported Entities There is automatic reflection support for: Tables Views Functions","title":"Entities"},{"location":"supported_entities/#supported-entities","text":"There is automatic reflection support for: Tables Views Functions","title":"Supported Entities"},{"location":"supported_types/","text":"Supported Types There is first class support for the following PG types: Boolean Integer BigInteger Float Numeric (casts to float) Text Timestamp (as ISO 8601 string) UUID Composite (excludes nested composites) Enum Other, unknown types, default to a String representation.","title":"Types"},{"location":"supported_types/#supported-types","text":"There is first class support for the following PG types: Boolean Integer BigInteger Float Numeric (casts to float) Text Timestamp (as ISO 8601 string) UUID Composite (excludes nested composites) Enum Other, unknown types, default to a String representation.","title":"Supported Types"}]}