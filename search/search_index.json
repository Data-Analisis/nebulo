{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Nebulous Documentation : https://olirice.github.io/nebulous/ Instant GraphQL API for PostgreSQL Nebulous reflects a highly performant GraphQL API from an existing PostgreSQL database. WARNING: pre-alpha software TL;DR First, install nebulous $ pip install nebulous Then point the nebulous CLI at an existing PostgreSQL database using connection string format postgresql://<user>:<password>@<host>:<port>/<database_name> neb run -c postgresql://nebulous_user:password@localhost:4443/nebulous_db Visit your shiny new GraphQL API at http://localhost:5018/graphql Installation Requirements : Python 3.7+, PostgreSQL 11+ Pip install the nebulous CLI $ pip install nebulous Next, check out the quickstart guide for a small end-to-end example. \u2014\u2014 \u2014\u2014","title":"Introduction"},{"location":"#nebulous","text":"Documentation : https://olirice.github.io/nebulous/ Instant GraphQL API for PostgreSQL Nebulous reflects a highly performant GraphQL API from an existing PostgreSQL database. WARNING: pre-alpha software","title":"Nebulous"},{"location":"#tldr","text":"First, install nebulous $ pip install nebulous Then point the nebulous CLI at an existing PostgreSQL database using connection string format postgresql://<user>:<password>@<host>:<port>/<database_name> neb run -c postgresql://nebulous_user:password@localhost:4443/nebulous_db Visit your shiny new GraphQL API at http://localhost:5018/graphql","title":"TL;DR"},{"location":"#installation","text":"Requirements : Python 3.7+, PostgreSQL 11+ Pip install the nebulous CLI $ pip install nebulous Next, check out the quickstart guide for a small end-to-end example. \u2014\u2014 \u2014\u2014","title":"Installation"},{"location":"performance/","text":"Performance Page Not Complete Key Points: - All queries are handled in a single round-trip to the database. No N+1 problems here! - SQL queries only fetch requested fields which also (reduces IO and improves performance) - SQL queries return JSON which significantly reduces database IO when joins are present","title":"Performance"},{"location":"performance/#performance","text":"Page Not Complete Key Points: - All queries are handled in a single round-trip to the database. No N+1 problems here! - SQL queries only fetch requested fields which also (reduces IO and improves performance) - SQL queries return JSON which significantly reduces database IO when joins are present","title":"Performance"},{"location":"quickstart/","text":"Quickstart For this example we're going to create a simple blogging platform. We'll start by creating a minimal database schema. Then we'll use nebulous to reflect our GraphQL API. Finally, we'll query from that API. Database Setup First, we need to define our database schema. We need a table for accounts, and another for blog posts. All blog posts must be associated with an author in the accounts table. -- blog_schema.sql CREATE TABLE public . account ( id SERIAL PRIMARY KEY , name TEXT NOT NULL , created_at TIMESTAMP NOT NULL DEFAULT now () ); CREATE TABLE public . blog_post ( id SERIAL PRIMARY KEY , title TEXT NOT NULL , body TEXT , author_id INT REFERENCES account ( id ), created_at TIMESTAMP NOT NULL DEFAULT now () ); INSERT INTO account ( id , name ) VALUES ( 1 , 'Oliver' ), ( 2 , 'Buddy' ); INSERT INTO blog_post ( id , author_id , title ) VALUES ( 1 , 1 , 'First Post!' ), ( 2 , 1 , 'Sanitize all the things!' ), ( 3 , 2 , 'To Bite or not to Bite' ); GraphQL Schema Now we're ready to reflect our new database schema into a GraphQL schema. The GraphQL schema document describes our API's types, fields, and relationships between entities. If you're new to GraphQL check out their documentation for more information. To inspect the GraphQL schema neb dump-schema -c postgresql://nebulous_user:password@localhost:4443/nebulous_db where the connection string provided by -c is in the format postgresql://<user>:<password>@<host>:<port>/<database_name> Which outputs the schema below schema { query: Query } type Account implements NodeInterface { nodeId: NodeID ! id: Int ! blogPostsByAuthorId ( first: Int , after: Cursor , condition: BlogPostCondition ): BlogPostConnection name: String ! createdAt: String ! } input AccountCondition { id: Int name: String createdAt: String } type AccountConnection { edges: [ AccountEdge !]! pageInfo: PageInfo ! totalCount: Int ! } type AccountEdge { cursor: Cursor node: Account } type BlogPost implements NodeInterface { nodeId: NodeID ! id: Int ! accountByAuthorId: Account title: String ! body: String authorId: Int createdAt: String ! } input BlogPostCondition { id: Int title: String body: String authorId: Int createdAt: String } type BlogPostConnection { edges: [ BlogPostEdge !]! pageInfo: PageInfo ! totalCount: Int ! } type BlogPostEdge { cursor: Cursor node: BlogPost } scalar Cursor scalar NodeID interface NodeInterface { nodeId: NodeID ! } type PageInfo { hasNextPage: Boolean ! hasPreviousPage: Boolean ! startCursor: Cursor ! endCursor: Cursor ! } type Query { account ( nodeId: NodeID ): Account blogPost ( nodeId: NodeID ): BlogPost allAccounts ( first: Int , after: Cursor , condition: AccountCondition ): AccountConnection allBlogPosts ( first: Int , after: Cursor , condition: BlogPostCondition ): BlogPostConnection } Notice that our API detected the foreign key relationship between Account and BlogPost and created blogPostsByAuthorId and accountByAuthorId on their base types respectively. Query the API To start the API server, execute neb run passing in a connection to the database. neb run -c postgresql://nebulous_user:password@localhost:4443/nebulous_db In addition to handling GraphQL requests, nebulous also serves the GraphiQL explorer locally at http://localhost:5018/graphql . Enter your query in GraphiQL and click the arrow icon to execute it. You're all done!","title":"Quickstart"},{"location":"quickstart/#quickstart","text":"For this example we're going to create a simple blogging platform. We'll start by creating a minimal database schema. Then we'll use nebulous to reflect our GraphQL API. Finally, we'll query from that API.","title":"Quickstart"},{"location":"quickstart/#database-setup","text":"First, we need to define our database schema. We need a table for accounts, and another for blog posts. All blog posts must be associated with an author in the accounts table. -- blog_schema.sql CREATE TABLE public . account ( id SERIAL PRIMARY KEY , name TEXT NOT NULL , created_at TIMESTAMP NOT NULL DEFAULT now () ); CREATE TABLE public . blog_post ( id SERIAL PRIMARY KEY , title TEXT NOT NULL , body TEXT , author_id INT REFERENCES account ( id ), created_at TIMESTAMP NOT NULL DEFAULT now () ); INSERT INTO account ( id , name ) VALUES ( 1 , 'Oliver' ), ( 2 , 'Buddy' ); INSERT INTO blog_post ( id , author_id , title ) VALUES ( 1 , 1 , 'First Post!' ), ( 2 , 1 , 'Sanitize all the things!' ), ( 3 , 2 , 'To Bite or not to Bite' );","title":"Database Setup"},{"location":"quickstart/#graphql-schema","text":"Now we're ready to reflect our new database schema into a GraphQL schema. The GraphQL schema document describes our API's types, fields, and relationships between entities. If you're new to GraphQL check out their documentation for more information. To inspect the GraphQL schema neb dump-schema -c postgresql://nebulous_user:password@localhost:4443/nebulous_db where the connection string provided by -c is in the format postgresql://<user>:<password>@<host>:<port>/<database_name> Which outputs the schema below schema { query: Query } type Account implements NodeInterface { nodeId: NodeID ! id: Int ! blogPostsByAuthorId ( first: Int , after: Cursor , condition: BlogPostCondition ): BlogPostConnection name: String ! createdAt: String ! } input AccountCondition { id: Int name: String createdAt: String } type AccountConnection { edges: [ AccountEdge !]! pageInfo: PageInfo ! totalCount: Int ! } type AccountEdge { cursor: Cursor node: Account } type BlogPost implements NodeInterface { nodeId: NodeID ! id: Int ! accountByAuthorId: Account title: String ! body: String authorId: Int createdAt: String ! } input BlogPostCondition { id: Int title: String body: String authorId: Int createdAt: String } type BlogPostConnection { edges: [ BlogPostEdge !]! pageInfo: PageInfo ! totalCount: Int ! } type BlogPostEdge { cursor: Cursor node: BlogPost } scalar Cursor scalar NodeID interface NodeInterface { nodeId: NodeID ! } type PageInfo { hasNextPage: Boolean ! hasPreviousPage: Boolean ! startCursor: Cursor ! endCursor: Cursor ! } type Query { account ( nodeId: NodeID ): Account blogPost ( nodeId: NodeID ): BlogPost allAccounts ( first: Int , after: Cursor , condition: AccountCondition ): AccountConnection allBlogPosts ( first: Int , after: Cursor , condition: BlogPostCondition ): BlogPostConnection } Notice that our API detected the foreign key relationship between Account and BlogPost and created blogPostsByAuthorId and accountByAuthorId on their base types respectively.","title":"GraphQL Schema"},{"location":"quickstart/#query-the-api","text":"To start the API server, execute neb run passing in a connection to the database. neb run -c postgresql://nebulous_user:password@localhost:4443/nebulous_db In addition to handling GraphQL requests, nebulous also serves the GraphiQL explorer locally at http://localhost:5018/graphql . Enter your query in GraphiQL and click the arrow icon to execute it. You're all done!","title":"Query the API"},{"location":"roadmap/","text":"Roadmap Todo: - Reflect Enum types - Reflect composite types - Reflect computed columns - Expose SQL functions as mutations - Parameterize generated queries to protect against SQL injection - Document usage as a library","title":"Roadmap"},{"location":"roadmap/#roadmap","text":"Todo: - Reflect Enum types - Reflect composite types - Reflect computed columns - Expose SQL functions as mutations - Parameterize generated queries to protect against SQL injection - Document usage as a library","title":"Roadmap"}]}