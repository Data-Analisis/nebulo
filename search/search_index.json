{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Nebulo Documentation : https://olirice.github.io/nebulo Source Code : https://github.com/olirice/nebulo Instant GraphQL API for PostgreSQL Reflect a highly performant GraphQL API from an existing PostgreSQL database. Nebulo is a python library for building GraphQL APIs on top of PostgreSQL. It has a command line interface for reflecting databases wtih 0 code or can be added to existing SQLAlchemy projects (pending documentation). Note: Alpha Software The public API is expected to evolve over the next year. Production usage is not reccomended at this stage. TL;DR First, install nebulo $ pip install nebulo Then point the CLI at an existing PostgreSQL database using connection string format postgresql://<user>:<password>@<host>:<port>/<database_name> neb run -c postgresql://nebulo_user:password@localhost:4443/nebulo_db Visit your shiny new GraphQL API at http://localhost:5034/graphiql Next, check out the quickstart guide for a small end-to-end example. \u2014\u2014 \u2014\u2014","title":"Introduction"},{"location":"#nebulo","text":"Documentation : https://olirice.github.io/nebulo Source Code : https://github.com/olirice/nebulo Instant GraphQL API for PostgreSQL Reflect a highly performant GraphQL API from an existing PostgreSQL database. Nebulo is a python library for building GraphQL APIs on top of PostgreSQL. It has a command line interface for reflecting databases wtih 0 code or can be added to existing SQLAlchemy projects (pending documentation). Note: Alpha Software The public API is expected to evolve over the next year. Production usage is not reccomended at this stage.","title":"Nebulo"},{"location":"#tldr","text":"First, install nebulo $ pip install nebulo Then point the CLI at an existing PostgreSQL database using connection string format postgresql://<user>:<password>@<host>:<port>/<database_name> neb run -c postgresql://nebulo_user:password@localhost:4443/nebulo_db Visit your shiny new GraphQL API at http://localhost:5034/graphiql Next, check out the quickstart guide for a small end-to-end example. \u2014\u2014 \u2014\u2014","title":"TL;DR"},{"location":"authentication/","text":"Authentication The approach to authentication and row level security were shamelessly borrowed from the postgraphile project, a similar (but much more mature) PostgreSQL to GraphQL project written in javascript. Please see their security documentation for instructions on setting up secure auth for api users. Note that JWT identifier and JWT secret can be passed to the nebulo CLI via --jwt-identifier \"public.my_jwt\" and --jwt-secret \"my_jwt_secret\" to cause functions returning the JWT type to reflect correctly.","title":"Authentication"},{"location":"authentication/#authentication","text":"The approach to authentication and row level security were shamelessly borrowed from the postgraphile project, a similar (but much more mature) PostgreSQL to GraphQL project written in javascript. Please see their security documentation for instructions on setting up secure auth for api users. Note that JWT identifier and JWT secret can be passed to the nebulo CLI via --jwt-identifier \"public.my_jwt\" and --jwt-secret \"my_jwt_secret\" to cause functions returning the JWT type to reflect correctly.","title":"Authentication"},{"location":"performance/","text":"Performance Performance Enabling Features: All queries are handled in a single round-trip to the database. No N+1 problems here! SQL queries only fetch requested fields SQL queries return JSON which significantly reduces database IO when joins are present Fully async / built on starlette Benchmarks Performance depends on netowrk, number of workers, log level etc. Despite all that, here are rough figures with postgres and the webserver running on a mid-tier 2017 Macbook Pro. Benchmarking 0.0.0.0 (be patient) Server Software: uvicorn Server Hostname: 0.0.0.0 Server Port: 5034 Document Path: / Document Length: 310 bytes Concurrency Level: 10 Time taken for tests: 5.571 seconds Complete requests: 1000 Failed requests: 0 Total transferred: 436000 bytes Total body sent: 245000 HTML transferred: 310000 bytes Requests per second: 179.49 [#/sec] (mean) Time per request: 55.712 [ms] (mean) Time per request: 5.571 [ms] (mean, across all concurrent requests) Transfer rate: 76.43 [Kbytes/sec] received 42.95 kb/s sent 119.37 kb/s total Connection Times (ms) min mean[+/-sd] median max Connect: 0 0 0.0 0 0 Processing: 17 55 18.7 52 98 Waiting: 17 55 18.7 51 98 Total: 18 55 18.7 52 98 Percentage of the requests served within a certain time (ms) 50% 52 66% 60 75% 65 80% 69 90% 80 95% 90 98% 94 99% 95 100% 98 (longest request) So approximately 180 requests/second responding in sub 100 milliseconds. Note that under normal load, response times are significantly faster. Percentage of the requests served within a certain time (ms) 50% 17 66% 19 75% 19 80% 20 90% 21 95% 24 98% 26 99% 30 100% 38 (longest request)","title":"Performance"},{"location":"performance/#performance","text":"Performance Enabling Features: All queries are handled in a single round-trip to the database. No N+1 problems here! SQL queries only fetch requested fields SQL queries return JSON which significantly reduces database IO when joins are present Fully async / built on starlette Benchmarks Performance depends on netowrk, number of workers, log level etc. Despite all that, here are rough figures with postgres and the webserver running on a mid-tier 2017 Macbook Pro. Benchmarking 0.0.0.0 (be patient) Server Software: uvicorn Server Hostname: 0.0.0.0 Server Port: 5034 Document Path: / Document Length: 310 bytes Concurrency Level: 10 Time taken for tests: 5.571 seconds Complete requests: 1000 Failed requests: 0 Total transferred: 436000 bytes Total body sent: 245000 HTML transferred: 310000 bytes Requests per second: 179.49 [#/sec] (mean) Time per request: 55.712 [ms] (mean) Time per request: 5.571 [ms] (mean, across all concurrent requests) Transfer rate: 76.43 [Kbytes/sec] received 42.95 kb/s sent 119.37 kb/s total Connection Times (ms) min mean[+/-sd] median max Connect: 0 0 0.0 0 0 Processing: 17 55 18.7 52 98 Waiting: 17 55 18.7 51 98 Total: 18 55 18.7 52 98 Percentage of the requests served within a certain time (ms) 50% 52 66% 60 75% 65 80% 69 90% 80 95% 90 98% 94 99% 95 100% 98 (longest request) So approximately 180 requests/second responding in sub 100 milliseconds. Note that under normal load, response times are significantly faster. Percentage of the requests served within a certain time (ms) 50% 17 66% 19 75% 19 80% 20 90% 21 95% 24 98% 26 99% 30 100% 38 (longest request)","title":"Performance"},{"location":"quickstart/","text":"Quickstart For this example we're going to create a simple blogging platform. We'll start by creating a minimal database schema. Then we'll use nebulo to reflect our GraphQL API. Finally, we'll query from that API. Installation Requires: Python 3.7+ pip install nebulo Database Setup If you don't have PostgreSQL installed locally, the following docker command creates an instance with the connection string used for the remainder of the quickstart guide. docker run --rm --name nebulo_demo -p 4443 :5432 -d -e POSTGRES_DB = nebulo_db -e POSTGRES_PASSWORD = password -e POSTGRES_USER = nebulo_user -d postgres Next, we need to define our database schema. We need a table for accounts, and another for blog posts. All blog posts must be associated with an author in the accounts table. Additionally, we don't want to allow users to update or delete their blog post. -- blog_schema.sql CREATE TABLE public . account ( id SERIAL PRIMARY KEY , name TEXT NOT NULL , created_at TIMESTAMP NOT NULL DEFAULT now () ); CREATE TABLE public . blog_post ( id SERIAL PRIMARY KEY , title TEXT NOT NULL , body TEXT , author_id INT REFERENCES account ( id ), created_at TIMESTAMP NOT NULL DEFAULT now () ); INSERT INTO account ( id , name ) VALUES ( 1 , 'Oliver' ), ( 2 , 'Buddy' ); INSERT INTO blog_post ( id , author_id , title ) VALUES ( 1 , 1 , 'First Post' ), ( 2 , 1 , 'Sanitize all the things!' ), ( 3 , 2 , 'To Bite or not to Bite' ); COMMENT ON TABLE blog_post IS E '@exclude update, delete' ; Note the comment to exclude updates and deletes from blog posts. The same comment format can also be applied to exclude columns from reflection e.g. password hashes. GraphQL Schema Now we're ready to reflect the database schema into a GraphQL schema. The GraphQL schema document describes our API's types, fields, and relationships between entities. If you're new to GraphQL check out their documentation for more information. To inspect the GraphQL schema neb dump-schema -c postgresql://nebulo_user:password@localhost:4443/nebulo_db where the connection string provided by -c is in the format postgresql://<user>:<password>@<host>:<port>/<database_name> Which outputs the schema below type Query { \"\"\"Reads a single Account using its globally unique ID\"\"\" account ( nodeId: ID !): Account \"\"\"Reads and enables pagination through a set of Account\"\"\" allAccounts ( first: Int , last: Int , before: Cursor , after: Cursor , condition: accountCondition ): AccountConnection \"\"\"Reads a single BlogPost using its globally unique ID\"\"\" blogPost ( nodeId: ID !): BlogPost \"\"\"Reads and enables pagination through a set of BlogPost\"\"\" allBlogPosts ( first: Int , last: Int , before: Cursor , after: Cursor , condition: blogPostCondition ): BlogPostConnection } type Mutation { \"\"\"Creates a single Account.\"\"\" createAccount ( input: CreateAccountInput !): CreateAccountPayload \"\"\"Updates a single Account using its globally unique id and a patch.\"\"\" updateAccount ( input: UpdateAccountInput !): UpdateAccountPayload \"\"\"Delete a single Account using its globally unique id and a patch.\"\"\" deleteAccount ( input: DeleteAccountInput !): DeleteAccountPayload \"\"\"Creates a single BlogPost.\"\"\" createBlogPost ( input: CreateBlogPostInput !): CreateBlogPostPayload } type Account implements NodeInterface { nodeId: ID ! id: Int ! name: String ! createdAt: DateTime ! \"\"\"Reads and enables pagination through a set of BlogPost\"\"\" blogPostsByIdToAuthorId ( first: Int , last: Int , before: Cursor , after: Cursor , condition: blogPostCondition ): BlogPostConnection ! } \"\"\"An object with a nodeId\"\"\" interface NodeInterface { \"\"\"The global id of the object.\"\"\" nodeId: ID ! } scalar DateTime type BlogPostConnection { edges: [ BlogPostEdge !]! pageInfo: PageInfo ! totalCount: Int ! } type BlogPostEdge { cursor: Cursor node: BlogPost } scalar Cursor < abridged output > Notice that our API detected the foreign key relationship between Account and BlogPost and created blogPostsByIdToAuthorId and accountByAuthorIdToId on their base types respectively. Query the API To start the API server, execute neb run passing in a connection to the database. neb run -c postgresql://nebulo_user:password@localhost:4443/nebulo_db In addition to handling GraphQL requests, nebulo also serves the GraphiQL explorer locally at http://localhost:5034/graphiql . Enter your query in GraphiQL and click the arrow icon to execute it. You're all done!","title":"Quickstart"},{"location":"quickstart/#quickstart","text":"For this example we're going to create a simple blogging platform. We'll start by creating a minimal database schema. Then we'll use nebulo to reflect our GraphQL API. Finally, we'll query from that API.","title":"Quickstart"},{"location":"quickstart/#installation","text":"Requires: Python 3.7+ pip install nebulo","title":"Installation"},{"location":"quickstart/#database-setup","text":"If you don't have PostgreSQL installed locally, the following docker command creates an instance with the connection string used for the remainder of the quickstart guide. docker run --rm --name nebulo_demo -p 4443 :5432 -d -e POSTGRES_DB = nebulo_db -e POSTGRES_PASSWORD = password -e POSTGRES_USER = nebulo_user -d postgres Next, we need to define our database schema. We need a table for accounts, and another for blog posts. All blog posts must be associated with an author in the accounts table. Additionally, we don't want to allow users to update or delete their blog post. -- blog_schema.sql CREATE TABLE public . account ( id SERIAL PRIMARY KEY , name TEXT NOT NULL , created_at TIMESTAMP NOT NULL DEFAULT now () ); CREATE TABLE public . blog_post ( id SERIAL PRIMARY KEY , title TEXT NOT NULL , body TEXT , author_id INT REFERENCES account ( id ), created_at TIMESTAMP NOT NULL DEFAULT now () ); INSERT INTO account ( id , name ) VALUES ( 1 , 'Oliver' ), ( 2 , 'Buddy' ); INSERT INTO blog_post ( id , author_id , title ) VALUES ( 1 , 1 , 'First Post' ), ( 2 , 1 , 'Sanitize all the things!' ), ( 3 , 2 , 'To Bite or not to Bite' ); COMMENT ON TABLE blog_post IS E '@exclude update, delete' ; Note the comment to exclude updates and deletes from blog posts. The same comment format can also be applied to exclude columns from reflection e.g. password hashes.","title":"Database Setup"},{"location":"quickstart/#graphql-schema","text":"Now we're ready to reflect the database schema into a GraphQL schema. The GraphQL schema document describes our API's types, fields, and relationships between entities. If you're new to GraphQL check out their documentation for more information. To inspect the GraphQL schema neb dump-schema -c postgresql://nebulo_user:password@localhost:4443/nebulo_db where the connection string provided by -c is in the format postgresql://<user>:<password>@<host>:<port>/<database_name> Which outputs the schema below type Query { \"\"\"Reads a single Account using its globally unique ID\"\"\" account ( nodeId: ID !): Account \"\"\"Reads and enables pagination through a set of Account\"\"\" allAccounts ( first: Int , last: Int , before: Cursor , after: Cursor , condition: accountCondition ): AccountConnection \"\"\"Reads a single BlogPost using its globally unique ID\"\"\" blogPost ( nodeId: ID !): BlogPost \"\"\"Reads and enables pagination through a set of BlogPost\"\"\" allBlogPosts ( first: Int , last: Int , before: Cursor , after: Cursor , condition: blogPostCondition ): BlogPostConnection } type Mutation { \"\"\"Creates a single Account.\"\"\" createAccount ( input: CreateAccountInput !): CreateAccountPayload \"\"\"Updates a single Account using its globally unique id and a patch.\"\"\" updateAccount ( input: UpdateAccountInput !): UpdateAccountPayload \"\"\"Delete a single Account using its globally unique id and a patch.\"\"\" deleteAccount ( input: DeleteAccountInput !): DeleteAccountPayload \"\"\"Creates a single BlogPost.\"\"\" createBlogPost ( input: CreateBlogPostInput !): CreateBlogPostPayload } type Account implements NodeInterface { nodeId: ID ! id: Int ! name: String ! createdAt: DateTime ! \"\"\"Reads and enables pagination through a set of BlogPost\"\"\" blogPostsByIdToAuthorId ( first: Int , last: Int , before: Cursor , after: Cursor , condition: blogPostCondition ): BlogPostConnection ! } \"\"\"An object with a nodeId\"\"\" interface NodeInterface { \"\"\"The global id of the object.\"\"\" nodeId: ID ! } scalar DateTime type BlogPostConnection { edges: [ BlogPostEdge !]! pageInfo: PageInfo ! totalCount: Int ! } type BlogPostEdge { cursor: Cursor node: BlogPost } scalar Cursor < abridged output > Notice that our API detected the foreign key relationship between Account and BlogPost and created blogPostsByIdToAuthorId and accountByAuthorIdToId on their base types respectively.","title":"GraphQL Schema"},{"location":"quickstart/#query-the-api","text":"To start the API server, execute neb run passing in a connection to the database. neb run -c postgresql://nebulo_user:password@localhost:4443/nebulo_db In addition to handling GraphQL requests, nebulo also serves the GraphiQL explorer locally at http://localhost:5034/graphiql . Enter your query in GraphiQL and click the arrow icon to execute it. You're all done!","title":"Query the API"},{"location":"supported_entities/","text":"Supported Entities There is automatic reflection support for: Tables Views Functions","title":"Supported Entities"},{"location":"supported_entities/#supported-entities","text":"There is automatic reflection support for: Tables Views Functions","title":"Supported Entities"}]}